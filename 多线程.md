# 多线程学习记录
## 编译方式
> 在linux中，需要添加参数 -lpthread, 即最终编译方式为:
```bash
g++ test.cpp -lpthread -o test
 ```
## `<thread>`
```C++
#include <thread>
void funa() {
  cout << "fun()" << endl;
}
void funb(int x) {
  cout << "funb(int)" << endl;
}
void func(int& x) {
  cout << "func(int&)" << endl;
}
void fund(int* x) {
  cout << "fund(int*)" << endl;
}
int main(){
  int x = 10;
  std::thread tha(funa);
  std::thread thb(funb, x);
  std::thread thc(func, std::ref(x));  // 传引用必须使用std::ref申明
  std::thread thd(fund, &x);

  thb.join(); 
  tha.join();
  thc.join();
  thd.join();
    return 0;
}
```
  - 构造函数
  > 需要注意的是： 当线程函数的参数是以引用的方式，需要用 std::ref()进行声明
  - join()
  > join函数的功能是等待线程结束。
> 输出紊乱，由于进程宏观上是同时运行的。所以输出会紊乱
## `<atomic>`
> 原子变量，可以达到互斥访问的效果
```C++
#include <atomic>
#include <thread>
std::atomic_int x;
std::atomic<int> x; // 与前者效果相同

```
