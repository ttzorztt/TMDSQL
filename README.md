
# TMDSQL_1.1(正在更新ing)

## 运行须知

> 根据系统版本划分为两个，Linux(Debain11)版本，Windows(Windows10专业版)两个版本，下载前请先查看Readme，获得TMDSQL所支持的语法。该可执行文件首先会生成一些辅助文件，会在当前目录生成data文件夹，存放一些辅助文件。(linux需要管理员权限),系统预置超级管理员，帐号为:root,密码为root,具体可见User文件夹下的pd文件。所支持的语句或功能需要查看备注，特别标出的是最新功能，上一个版本可能不支持。如需要最新版本，需要下载源码进行make编译。

- 编译系统环境是在linux(Debain)中，gcc的版本是:`gcc version 10.2.1 20210110 (Debian 10.2.1-6)`,进入源码后，使用

  ```bash
  make
  ```
  
  指令可以生成linux版本的TMDSQL
- 附带版本windows，是在linux(Debain)采取交叉编译的方式，需要首先下载交叉编译链:

  ```bash
  sudo apt install mingw-w64*
  ```

  进入源码后，使用

    ```bash
    make TMDSQL.exe
    ```

  即可得到windows版本的TMDSQL.exe

### 编码

#### Windows版本(Windows 10专业版)

  > 本项目的windows版本采取GBK的编码方式，您需要查看您所使用的终端的编码方式,使用如下代码:

  ```cmd
  chcp
  ```

  >如果返回 `936`,则说明您当前系统所采取的编码方式是GBK。那么就不需要进行修改。但如果您返回的是其他编码方式，则需要进行编码设置，您可以使用如下命令:

  ```cmd
  chcp 936
  ```

  >来暂时设置，以便于使用该数据库。至于我采取GBK作为windows版本的编码，是因为windows默认采取的编码方式是GBK，但还是需要进行验证，以便于执行时出现乱码。
  
#### Linux版本(Debain 11)

- 本项目采用UTF-8的编码方式，而在UTF-8的编码方式中，一个汉字是三个字节。而项目编写时采取的环境是`gcc version 10.2.1 20210110 (Debian 10.2.1-6)`,linux中默认采取UTF-8的编码方式。(需要管理员权限)

## 总体思路

> 对数据库的数据，我采取目录对应数据库，文件对应表的方式。除了数据库目录和表文件以外，我仿照Linux对于锁的建立，用'.'开头的隐藏文件同名文件建立锁，对于文件的读取，我采取字符型存取，大量数据的文件读取速度如果仅仅采取按行存取则会很慢，那么我借助文件指针的思想，建立索引文件，用来保存索引字段与文件指针的对于关系，以便于后期直接根据文件指针的位置随机存取。而索引文件本身很大，借助操作系统中的段页式文件，于是我建立二级索引文件以加快查询。而索引文件本身是有序的，采取二分折半查找的方式查询。

## src目录及其主要功能介绍

### `dir.h && dir.cpp`

  > 主要实现目录操作，在内核中，目录对应于数据库，封装_dir类。

### `file.h && file.cpp`

  > 封装文件操作类_file,在内核中，文件对应表。

### `DataBase.h && DataBase.cpp`

  > 公有继承_dir类，调用一些_file的静态函数以辅助实现对数据库本身的操作

### `table.h && table.cpp`

  > 公有继承_file类，封装一些对表本身的操作

### `shell.h && shell.cpp`

  > 对中文TMDsql语句的封装

### `super.h && super.cpp`

  > 对所有公有函数，枚举量以及全局静态const常量的声明与定义。

### `Index.h && Index.cpp`

  > 封装对表索引操作的声明与定义

### `TablePCB.h && TablePCB.cpp`

  > 封装对表PCB操作的声明与定义

### `User.h && User.cpp`

  > 封装用户类，实现用户的增删查操作。以及对用户的权限划分，分为四类，分别是：未登录，用户，管理员，超级管理员

### `menuOutput.h && menuOutput.cpp`

  > 封装报错输出以及正常终端输出。

### `Log.h && Log.cpp` (V1.1支持)

  > 对日志进行记录

## data目录的结构

### database

  > 数据库存放路径，其子文件夹为各个数据库文件夹，文件夹名即为数据库名，而该文件夹内，为表名，不含后缀，可以拿记事本以UTF-8的编码方式打开，内置数据存放方式是以CSV方式存放。

### index

  > 索引文件存储路径，其子文件夹为各个数据库文件夹，而在数据库文件夹中，并非存放表，而存放表的索引文件，命名方式与表名相同。

### PCB

  > PCB文件存储路径，其子文件夹为各个数据库文件夹，而在数据库文件夹中，存放表PCB文件。命名方式与表名相同。

### log

  > 日志文件存储路径，其内容为总日志记录

## tablePCB的内容

1. name
2. nextIndex：下一行的起始文件指针
3. length：行数

# shell语言解释器

## 字段解释

`ID` 是该指令的一个编号

### CID

`CID`是每个关键字的编号

### PWD

- pwd = `[]`,默认状态，说明当前未选择数据库，且未登录。此种状态不可以执行除去登录外的任何指令,均会输出:
  
  ```txt
  (未登录) -=> 未登录,请登录后操作!
  ```
  
- pwd = \["/"\],说明当前已经登录，并未知帐号信息，且没有选择数据库
- pwd = \["/"\]\["测试数据库1"\]， 说明当前已经登录，且已经选择一个名叫测试数据库的数据库。
- pwd = \["/"\]\["测试数据库1"\]\["测试表1"\]，说明当前已经登录，且当前已经选择测试数据库1下的测试表1

## 用户权限管理

`OP` 为权限值，分为四种权限

- `OP`=0 为Root权限

    ```txt
    pwd = ["/]
    ```

- `OP`=1 为管理员权限
  
  ```txt
  pwd = ["/"]
  ```
  
- `OP`=2 为普通用户权限
  
  ```txt
  pwd = ["/"]
  ```
  
- `OP`=3 为未登录权限
  
  ```txt
  pwd = []
  ```

> 权限显而易见是ROOT > 管理员权限 > 普通用户权限,而不同权限，可以做不同的操作，简单来说，普通用户只有查询和一些查看内容的操作，一切对于数据库的修改，比如数据库的创建，数据库的删除，表的创建，表的删除等必须具有管理员或超越管理员的权限，同时管理员具有添加删除普通用户的权限。而ROOT作为超级管理员，可以添加删除管理员帐号。

## 用户提示符

### 未登录
  
  ```txt
  (未登录) -=>
  ```
  
### 普通用户
  
  ```txt
  (用户) -=>
  ```
  
### 管理员
  
  ```txt
  (管理员) -=>
  ```
  
### 超级管理员
  
  ```txt
  (超级管理员) -=>
  ```
  
## 支持语句

  > 总体来说，TMDSQL支持中文，且关键字之间用`空格`隔开，结尾没有封号，每条指令必读独立占据一行。
  
- **以下对于指令介绍，由于未知用户权限，将未知用户的用户提示符改为`(?) -=>`**
- **加粗字体为关键字，斜体为用户输入随意字符串,需要使用@开头，后面的则不需要**
- 未登录用户只允许执行`显示`，`退出`和`登录`指令，其余指令均会拒绝执行并输出：
  
  ```txt
  (未登录) -=> 未登录,请登录后操作!
  ```
  
### **`退出`**

- 使用`退出`指令，会结束SQL执行。并输出:
  
  ```txt
  已退出!
  ```

### **`选择`**

- **选择** **数据库** _@测试数据库1_
  - 若数据库不存在

    ```txt
     目标数据库不存在!
    ```

- **选择** **表**  _@测试表1_
  - 没有选择数据库，则无法选择，提示:

    ```txt
    该指令无法执行，没有选择数据库!
    ```

  - 已经选择数据库，且已经选择的数据库中有没有测试表1,提示:

    ```txt
    无法执行该指令，该数据库中不存在此表
    ```

- **选择**  **数据库**  **表**  _@测试数据库1_  _测试表1_
  - 若测试数据库1不存在，则提示:

    ```txt
    目标数据库不存在!
    ```

  - 如果测试数据库1中没有测试表1，则显示:

    ```txt
    无法执行该指令，该数据库中不存在此表
    ```

### **`显示`**

- **显示**
  - 使用`显示`指令，根据当前的pwd分为四种情况：
    - pwd = []  

      ```txt
      (未登录) -=> 未登录,请登录后操作!
      ```

    - pwd = ["/"]
  
      ```txt
      (?) -= > 当前路径为: /
      ```

    - pwd = \["/"]\["测试数据库1"]

      ```txt
      (?) -= > 当前路径为: /测试数据库1
      ```

    - pwd = \["/"]\["测试数据库1"]\["测试表1"]

      ```txt
      (?) -= > 当前路径为: /测试数据库1/测试表1
      ```

- **显示**  **数据库**
  - 该指令需要登录后可使用。显示当前系统中所有数据库。假设当前数据库内有DB1,DB2,DB3三个数据库，则使用该指令后显示:

    ```txt
     #######
     ? DB1 ?
     ? DB2 ?
     ? DB3 ?
     #######
    ```

- **显示**  **数据库**   _@DBID_(=pwd[1])
  - 该指令需要登录后使用，可以选择到表后使用该指令，效果可以显示指定数据库中所存的表。
    - 当该数据库不存在时:

    ```txt
    数据库不存在!
    ```
  
    - 当该数据库为空的时候:

    ```txt
    这个数据库是空的!
    ```

    - 当这个数据库有TB1,TB2,TB3三张表的时候：

      ```txt
      *******
      | TB1 |
      | TB2 |
      | TB3 |
      *******
      ```

- **显示**  **表**  _@TBID_
  - 该指令需要首先选择数据库，然后默认在该数据库下查询表的内容，默认显示前五行，也就是说`pwd.size() >= 2`
  - 如果执行这条语句之前没有`选择`数据库，那会提示:

  ```txt
  该指令无法执行，没有选择数据库!
  ```

  - 如果已经选择数据库，但选择的数据库内没有该表，

  ```txt
  无法执行该指令，该数据库中不存在此表!
  ```

  - 如果一切顺利，已选择数据库，且选择的数据库内有该表，则会正常输出。

- **显示**  **表**  _@TBID_  _showNumber_
  > 该指令是上一条指令的扩充，同样需要先选择数据库，然后默认在指定数据库下查询表的内容，而参数 _showNumber_ 是显示的行数，注意该参数存储类型是int，不能超过数据大小。

  - 同上，只是控制输出的行数
- **显示**  **数据库**  **表**  _@DBID_ _TBID_
  > 该指令不需要选择数据库，效果是按照默认参数5行显示指定TBID的内容
  - 如果数据库DBID不存在，则会提示:

  ```txt
  目标数据库不存在!
  ```

  - 如果数据库DBID存在，但是表TBID不存在，则会提示:

  ```txt
  无法执行该指令，该数据库中不存在此表!
  ```

  - 如果都正常，那自然正常输出咯。
- **显示**  **数据库**  **表**  _@DBID_ _TBID_ _showNumber_
  - 是上一条的扩充，将默认显示行数设置为 _showNumber_ 行

### **`登录`**

- **登录**  _@帐号_  _密码_
  - 登录成功:

    ```txt
    (?) -= > 登录成功，欢迎您,帐号!
    ```

  - 登录失败:
    - 帐号不存在:

      ```txt
      帐号不存在,登录失败!
      ```

    - 密码错误:

      ```txt
      密码错误,登录失败!
      ```

### **`执行`**

- **执行**    _@脚本名_
  > path是执行SQL语句的脚本文件。编码格式无论是windows系统版本还是linux版本，均需要采取UTF-8的编码格式。

  - 如果当前目录不存在该脚本,则会输出:

    ```txt
    无法执行该指令，目标脚本不存在!
    ```

- **注意: 需要将脚本放置于./data/SQL目录下，然后使用如上指令，脚本名需要是放置在SQL的全称，带后缀的那种。如果代码中间存在空行，会跳过空行后的内容，结束执行**

### **`创建`**

- **创建**  **用户**  _@ID_  _Password_

  > 该指令需要OP < 2,也就是需要管理员权限或者超级管理员ROOT权限才能执行。该指令会添加密码为Password的普通用户ID
  - 当用户ID存在时，提示:

  ```txt
  该用户已存在，无法添加!
  ```

  - 创建成功后提示:

  ```txt
  创建成功!
  ```

- **创建**   **管理员**   _@ID_ _password_
  > 该指令需要OP < 1,也就是需要超级管理员ROOT权限才能执行。会添加密码为password的管理员ID。
  - 当用户ID存在时，提示:

  ```txt
  该用户已存在，无法添加!
  ```

  - 创建成功后提示:

  ```txt
  创建成功!
  ```

- **创建**  **数据库**  _@DBID_
  > 该指令需要OP < 2,也就是管理员或超级管理员ROOT权限才可以执行。会创建名为DBID的数据库。
  - 如果DBID存在，则提示:

  ```txt
  无法执行该指令，目标数据库已存在!
  ```

  -如果DBID不存在，则执行成功，提示:

  ```txt
  创建成功!
  ```

- **创建**  **表**  _@TBID_
  > 该指令需要OP < 2，也就是管理员或超级管理员权限才可执行。但在此之前需要选定数据库。
  - 如果没有选择数据库的话会输出:

  ```txt
  该指令无法执行，没有选择数据库!
  ```

  - 如果已经选择数据库，但表TRID已存在，那会提示:

  ```txt
  无法执行该指令，目标表已存在!
  ```

  - 如果一切顺利，则显示:

  ```txt
  创建成功!
  ```

### **`删除`**

> 该指令需要管理员或者超级管理员权限才可执行。谨慎使用！针对不同的指令，系统将变着花样提示。

- **删除**  **数据库**  _@DBID_
  >该指令会删除名为DBID的数据库。执行首先会判断DBID存在与否，如果存在，系统将首先输出该数据库中存在的所有表，然后需要用户键入"确认"才可删除。
  - 如果数据库DBDI不存在，则会提示:

  ```txt
  目标数据库不存在!
  ```

  - 如果DBID是一个空数据库，那么就直接删除，并不需要输入确认:

  ```txt
  删除成功!
  ```

  - 如果DBID是一个非空数据库，且其中有表TB1，TB2，TB3和TT三张表，如果执行指令，则显示:

  ```txt
  数据库并不为空，以下为当前存在的表项
  *******
  | TB1 |
  | TB2 |
  | TB3 |
  | TT  |
  *******
  如果您仍然执意删除，请键入 "确定" :
  ```

  - 此时你需要在':'后键入确定。
    - 如果你没有输入`确定`而输出别的(包括只输入回车)，则会提示:

      ```txt
      该指令已取消!
      ```

    - 如果你输入`确定`,则会提示:

      ```txt
      删除成功!
      ```

- **删除**  **表**  _@TBID_
  > 该指令会删除名为TBID的表，当然执行该指令的前提是你首先得选择到数据库，系统会判断当前pwd的路径，如果pwd.size() > 2,且pwd[1]中有该表，系统会输出该表当前的前五行，然后同样需要用户键入"确认"才可删除。
  - 如果你没有选择数据库，则会提示：

  ```txt
  该指令无法执行，没有选择数据库!
  ```

  - 如果已选数据库，但pwd[1]中没有表TBID,则会提示：

  ```txt
  目标表不存在!
  ```

  - 如果存在，但表为空，执行会提示:

  ```txt
  删除成功!
  ```

  - 如果存在，且不为空的情况下，执行后提示:

  ```txt
  表不为空，以下是该表的一部分内容:
  测试1 测试2 测试3 
  测试1 测试2 测试3 
  如果您仍然执意删除，请键入 "确定" :
  ```

  - 此时你需要在':'后键入确定。
    - 如果你没有输入`确定`而输出别的(包括只输入回车)，则会提示:

      ```txt
      该指令已取消!
      ```

    - 如果你输入`确定`,则会提示:

      ```txt
      删除成功!
      ```

- **删除**  **数据库**  **表**  _@DBID_  _TBID_
  > 该指令会删除DBID下的TBID，首先判断DBID是否存在，且是否有TBID这张表，其实和上一个指令差不多，是将上一个指令中默认的pwd[1]修改为DBID执行而已。
  - 和上一条指令类似。
- **删除**  **用户**  _@UserName_
  > 该指令会删除名字为UserName的普通用户。
  - 当UserName不存在时，提示:

  ```txt
  该用户不存在!
  ```

  - 当与用户存在的时候，提示:

  ```txt
  删除成功!
  ```

- **删除**  **管理员**  _@managerID_
  > 该指令需要超级管理员ROOT权限才能执行。
  - 当managerID不存在时，提示:

  ```txt
  该管理员不存在!
  ```

  - 当与用户存在的时候，提示:

  ```txt
  删除成功!
  ```

### **`插入`**

  > 该指令同样需要管理员权限或超级管理员权限

- **插入** _[value1_ _value2_ _...]_  **_(V1.1支持)(当前已实现)_**
  > 该条指令需要用户选择到表，一切顺利的情况下，尾插value1，value2等数据。
  - 当未选择数据库的时候，会提示:

  ```txt
  该指令无法执行，没有选择数据库!
  ```

  - 当选择数据库但没有选择表的时候，
- **插入** **表** _@TBID_ _[value1_ _value2_ _...]_
  > 该条指令会在选择数据库，且该数据库内有TBID后可执行，尾插value1，value2等数据。
  - 当未选择数据库的时候，会提示:

  ```txt
  该指令无法执行，没有选择数据库!
  ```

  - 当已选择数据库，但pwd[1]中没有该表，则会显示:

  ```txt
  目标表不存在!
  ```

  - 当一切顺利，则会显示:

  ```txt
  插入成功!
  ```

- **插入** **数据库** **表** _@DBID_ _TBID_ _[value1 value2 ...]_
  > 该指令是上一条的扩展，无需先选择数据库，只要参数正确，指定数据库下的表尾插入指定集合即可。
  - 当数据库DBID不存在时，会提示:

  ```txt
  目标数据库不存在!
  ```

  - 当表不存在的时候,会提示:

  ```txt
  无法执行该指令，该数据库中不存在此表!
  ```

  - 当一切顺利，则会显示:

  ```txt
  插入成功!
  ```

### 查询

> 仅需登录，不查询权限等级

- **查询** **表** _@TBID_ _index_
  > 需要选择数据库，即pwd.size() > 1,pwd[1]中有表TBID，查询索引为index的内容。
  - 如果执行前没有选择数据库，则会显示:

  ```txt
  该指令无法执行，没有选择数据库!
  ```

  - 如果选择数据库后，但目标数据库内没有表TBID，则会显示：

  ```txt
  目标表不存在!
  ```

  - 如果TBID存在，但index并不在表TBID中，则会显示:

  ```txt
  搜索结束，没有搜到目标值!
  ```

  - 如果index存在，则会返回搜索到的值。

- **查询** **数据库** **表** _@DBID_ _TBID_ _index_
  > 不需要选择数据库，属于权限最小的一系列指令，只需登录即可执行。查询DBID下的TBID中索引为index的内容。
  - 数据库DBID不存在,则会输出:
  
  ```txt
  目标数据库不存在!

  ```

  - 数据库DBID存在，但是表TBID不存在，则会输出:

  ```txt
  目标表不存在!
  ```

  - 数据库DBID存在且表TBID存在，但是没有搜到Index，则会输出：

  ```txt
  搜索结束，没有搜到目标值!
  ```

  - 如果搜到，则会正常显示搜索内容。

## 日志系统(V1.1支持)(当前未实现)

  > 建立Log类，实现日志的记录。
  
- 按照日期划分文件
- 任何调用记录，均会在log文件夹内显示。log文件夹内存储LOG文件，记录所有操作内容，以及执行结果，包括但不限于:
  - 系统登录时间以及登出时间
  - 用户操作内容以及成功与否

- 日志内容(三行)：
  - 是否执行成功("V" or "X"),时间(包括日期和时间)
  - 失败原因(如果成功则输出顺利执行)
  - 执行人:执行指令(对一些缩写指令进行扩充。避免查看上下文)

- 日志记录项
  - 系统初始化(系统初次使用)
  - 登入系统(打开系统)
  - **指令记录**
  - 登出系统(关闭系统)

- 指令记录详解
  
  ```txt
  < 1 > [2] (3)
  4
  5{6} -=> 7
  ```

  1. 执行是否顺利(V或X)
  2. 日期
  3. 时间
  4. 执行细则(是否顺利，顺利的话显示"顺利执行"，否则显示错误内容)
  5. 权限等级
  6. 用户名
  7. 执行内容(包括指令和数据)
  
  - 比如:

  ```txt
  ```

- 日志记录指令集
  > 缩写类指令按照对应pwd进行补全后记录在日志中
  - 退出(不修改)
  - 选择
    - **选择** **数据库** _@DBID_
    - **选择** **数据库** **表** _@DBID_ _TBID_
  - 显示
    - **显示**
    - **显示** **数据库**
    - **显示** **数据库** _@DBID_
    - **显示** **数据库** **表** _@DBID_ _TBID_
  - 登录(不修改)
  - 创建
    - **创建** **用户** _@ID_ _Password_
    - **创建** **管理员**   _@ID_ _password_
    - **创建**  **数据库**  _@DBID_
    - **创建**  **数据库** **表**  _@DBID_ _TBID_
  - 删除
    - **删除**  **数据库**  _@DBID_
    - **删除** **数据库**  **表**  _@DBID_ _TBID_
    - **删除**  **用户**  _@UserName_
    - **删除**  **管理员**  _@managerID_
  - 插入
    - **插入** **数据库** **表** _@DBID_ _TBID_ _[value1 value2 ...]_
  - 查询
    - **查询** **数据库** **表** _@DBID_ _TBID_ _index_

## BUG记录

### linux下交叉编译windows程序

> 安装Mingw，命令如下：

```bash
sudo apt install mingw-w64*
```

安装后`x86_64-w64-mingw32-g++`进行编译和链接

### 不同操作系统下使用不同的命令

使用如下预处理:

```c++
#ifndef __WIN32__
#endif
#ifndef __linux__
#endif
```

### windows下执行缺少动态库libxxx.dll

> 使用g++的使用采取动态编译的方式。需要采取静态方式，添加如下参数：

```bash
x86_64-w64-mingw32-g++ -static -c xxx.cpp -o xxx.o
```

### ifstream 的seekg失效

> 在读取文件的时候，读取到文件结尾后尝试使用seekg设置指针重新指向-1，但无法使用readline读取，诡异的是使用tellg返回的居然是设置后的-1。

- 尝试1: 使用clear函数，无效。如果没有查询到eof重新设置seek有效，但并不知道是否到了eof。
- 尝试2: 既然最开始可以使用，那么不如关闭后重新打开。成功。如此每次setseek的时候，查看一下eof的状态。如果达到文件尾的时候，就close后重新open
